## 1. 이 책은 어떤 설계를 주제로 집필한 것 인가?

이 책엣허 다룬 설계는 주로 유지 보수성과 관련 있는 품질 특성이었다. 유지 보수성은 ‘시스템이 정상 운용되도록 유지 보수하기가 얼마나 쉬운가를 나타내는 정도’라고 했다. 유지 보수성 중에서도 특히 **변경 용이성을 목적으로 하는 설계 방법**을 다루어 왔다.

## 2. 설계하지 않으면 개발 생산성이 저하된다.

변경이 어렵고 버그가 생기기 쉬운 코드를 레거시 코드라고 한다. 레거시 코드가 축적되어 있는 상태를 기술 부채라고 한다.

변경 용이성 설계를 하지 않으면, 개발 생산성이 저하된다.

### 요인 1. 버그가 발생하기 쉬운 구조

-   응집도가 낮은 구조로 인해 사양 변경 시 수정 누락이 발생하기 쉬워지고, 결국 버그가 발생
-   코드를 이해하기 어려우므로 구현할 떄 실수를 저지르기 쉬워지고, 버그가 발생
-   잘못된 값이 들어오기 쉬워지고, 버그가 발생

### 요인2. 가독성이 낮은 구조

가독성이 저하되면, 의도를 정확하게 이해하는 데 시간이 오래 걸린다.

-   로직의 가독성이 낮아, 읽고 이해하는데 시간이 오래 걸림
-   관련된 로직이 이곳 저곳 흩어져 있어, 사양을 변경할 떄 관련된 로직을 찾아서 돌아다니는 데 시간이 오래걸림
-   잘못된 값이 들어와서 버그가 발생했을 때, 잘못된 값의 출처를 추적하기 어려워짐

### 나무꾼의 딜레마

> 나무꾼이 도끼로 열심히 나무를 베고 있었다.
> 그때 지나가던 여행자가 나무가 잘 베이지 않은 것을 보고, “도끼를 갈고 나무를 베는 것이 좋지 않을까요?” 라고 하자 “알고 있지만, 나무를 베는 것이 바빠서 도끼를 갈 시간이 없어요!” 라고 답했다.

이는 소프트웨어 개발에서도 발생하고, 제대로 설계하지 않으면, 로직 변경과 디버그에 많은 시간을 소비하게 되고, 결국 설계할 시간 여유조차 없어지는 딜레마에 빠진다.

### 열심히 일했지만 생산성이 나쁨

개발 생산성이 나쁘면 새로운 기능을 릴리스하는 데 굉장히 오래 걸린다. 어떻게든 일단 작동하게 만들려고 구현과 수정을 계속 반복하지만 생산성이 나빠 성과가 제대로 나지 않는다. 결국 ‘이렇게 열심히 일했는데도 왜 성과가 안나는 거야!’ 라며 분노하고 스스로에게 실망하게 되곤 한다.

### 국가 규모의 경제 손실

레거시 코드로 인한 생산성 저하로 발생하는 손실은 꽤 많다. 복잡하고 이해하기 힘든 로직이 있으면, 이로 인해 더 복잡하고 이해하기 힘든 로직이 만들어지기 때문에 소스 코드가 거대해지고 문제가 점점 가속화 된다.

설계를 소홀히 하고 매일 낮은 생산성을 방치하면, 국가 규모의 손실이 발생할 수 있다.

## 3. 소프트웨어와 엔지니어의 성장 가능성

코드의 변경 용이성이 높을수록, 소프트웨어의 가치를 빠르게 높일 수 있다.

### 엔지니어에게 자산이란 무엇인가?

엔지니어에게 자산이란 **기술력**이다. 기술력이 있다면, 모아 놓은 돈이 없어도 어디서든 돈을 벌 수 있다.

### 레거시 코드는 발전을 막음

신입이 레거시 코드가 많은 프로젝트 개발을 담당하게 된다면 ‘선배가 작성한 좋은 코드구나’ 또는 ‘전임 담당자는 이렇게 효율적으로 작업했구나’ 하고 레거시 코드를 추가로 양산하게 된다.

즉 낮은 수준의 기술만 사용하게 만든다.

### 레거시 코드는 고품질 설계 경험을 막음

레거시 코드는 이미 균형이 깨져 있어서, 설계를 개선하기가 매우 힘들다. 그렇게 되면 설계 개선을 일정 등으로 인한 이유료 포기하고 결국 설계 능력이 향상되지 않는다.

## 4. 문제 해결하기

-   문제를 인식하지 못하면 설계에 대한 생각 자체가 떠오르지 않음
-   인지하기 쉬운 문제와 인지하기 어려운 문제가 있음

[]()

-   이상적인 형태를 알아야 문제를 인식할 수 있음
-   변경 용이성을 비교할 수 없는 딜레마
    -   성능과 달리 곧바로 비교할 수 없다.
    -   미래의 변경 비용이 얼마나 낮은지 나타내는 것이기에 시간이 경과해야 알 수 있기 때문이다.

## 5. 코드의 좋고 나쁨을 판단하는 지표

### 실행되는 코드의 줄 수

주석을 제외하고, 실행되는 로직을 포함하는 코드의 줄 수를 의미한다. 줄 수가 많으면 많은 일을 하고 있을 가능성이 높다. 줄 수가 너무 많다면 ‘메서드와 클래스분할’을 검토해 봐라

### 순환 복잡도

순환 복잡도는 코드의 구조적인 복잡함을 나타내는 지표이다. **조건 분기, 반복 처리, 중첩**은 복잡도를 높인다.

| 순환 복잡도 | 복잡함의 상태                   | 버그 확률 |
| ----------- | ------------------------------- | --------- |
| 10이하      | 굉장히 좋은 구조                | 25%       |
| 30이상      | 구조적인 리스크가 존재          | 40%       |
| 50이상      | 테스트 불가능                   | 70%       |
| 75이상      | 변경할 때, 반드시 실수가 발생함 | 98%       |

클래스의 복잡도는 일반적으로 10정도 높아도 15보다는 낮게 나오는 것이 좋다.

### 응집도

응집도는 모듈 내부에서 데이터와 로직이 관련되어 있는 정도를 나타내는 지표이다. 모듈은 클래스, 패키지, 레이어 등 다양하게 해석할 수 있다. 클래스의 경우 데이터와 로직의 관계가 얼마나 강한지 나타내는 지표라고 생각하면 된다.

응집도가 높을수록 변경 용이성이 높고 좋은 구조이다.

### 결합도

결합도는 모듈 간의 의존도를 나타내는 지표이다. 결합도가 높다는 것은 의존하고 있는 클래스가 많다는 것으로 더 넓은 범위를 고려해야 하므로 유지보수와 사양 변경이 어렵다.

이는 단일 책임 원칙을 위배하고 있을 수 있다. 의존을 더줄이거나 클래스를 더 작게 분할할 수 없는지 검토해 보는 것이 좋다.

### 청크

청크는 기억할 수 있는 정보 덩어리의 단위이다. 프로그래밍은 데이터/로직을 보는 직업이므로 수천~수만 줄의 클래스를 보며 파악한다면 어려울 것이다.

## 6. 설계 대상과 비용 대비 효과

### 파레토의 법칙(80:20의 법칙)

전체 결과의 80%가 전체 원인의 20%에서 일어난다는 법칙이다. 소프트웨어의 기능 전체 중에서 중점적으로 사용되는 기능은 1/3정도 밖에 되지 않는다. 중요하고 사양 변경이 빈번한 곳의 설계를 개선하면, 비용 대비 효과가 높을 것이다.

### 코어 도메인: 서비스의 중심 영역

서비스에서 중심이 되는 비지니스 영역을 **코어 도메인**이라고 한다.

-   시스템에서 가장 큰 가치를 창출하는 곳
-   가치 있고 중요하고 비용 대비 효과가 가장 큰 곳
-   경쟁 우위에 있고, 차별점을 만들며, 비지니스 우위를 만들 수 있는 곳

### 중점 설계 대상 선정에는 비지니스 지식이 필요함

서비스는 런칭 후에 반복해서 다양한 기능이 추가된다. 이때 중요한 기능은 높은 빈도로 사양 변경이 일어나는 경향이 있다. 설계 비용 대비 효과를 높이려면, 중점적인 설계 대상을 선정할 수 있어야 한다. 그 대상을 잘 선정하려면, 서비스의 본질이 무엇인지 볼 수 있는 능력이 필요하다.
