# 10장 이름 설계: 구조를 파악할 수 있는 이름

이름을 대충 붙이다 보면, 책무가 엉켜 강한 결합이 되고, 클래스가 거대해져 갓 클래스가 되기도 합니다.

목적 중심 이름 설계는 이름에서 목적과 의도를 읽고 이해할 수 있게 설계하는 것입니다.

참고로 고객 대상 제품 개발에서는 "회사에서 사업적으로 어떤 목적을 달성하고 싶은가"라는 비즈니스 목적이 중요한 역할을 하므로,<br> 
이 책에서는 비즈니스 목적을 중심으로 이야기합니다.

## 1. 악마를 불러들이는 이름

온라인 쇼핑몰을 예로 들어 보겠습니다.<br>
흔히 볼 수 있는 좋지 않은 이름 설계는 상품을 그대로 "상품 클래스"라고 이름을 붙이는 것입니다.<br>
이름을 단순하게 상품 클래스라고 붙이면 재고(출고), 예약, 주문, 발송 등 여러 유스케이스와 관계를 맺게 됩니다.<br>
강한 결합 구조가 되어버리는 것입니다. <br>
또한, 영향 범위가 너무 넓어 개발 생산성도 저하됩니다.

### 1.1 관심사 분리

강한 결합을 해소하고, 결합이 느슨하고 응집도가 높은 구조로 만들려면 "**관심사 분리**"를 할 수 있어야 합니다.<br>
관심사 분리는 "관심사(유스케이스, 목적, 역할)에 따라서 분리한다"라는 소프트웨어 공학의 개념입니다.

따라서 상품 클래스는 관심사에 따라서 각각 클래스로 분할해야 합니다.

### 1.2 관심사에 맞는 이름 붙이기

위의 예시의 상품 클래스를 재고 상품, 예약 상품, 주문 상품, 발송 상품의 네 클래스로 나눌 수 있습니다.<br>
분할한 후에는 분할한 클래스 각각에 관심사에 맞는 로직을 캡슐화하면 됩니다.<br>
이렇게 관심사에 따라 분리하면, 결합도를 낮추고 응집도를 높일 수 있습니다.<br>
각각의 상품 클래스의 영향 범위가 줄었으므로, 개발 생산성도 향상될 것입니다.

### 1.3 포괄적이고 의미가 불분명한 이름

상품 클래스 처럼 의미가 너무 포괄적인 이름은 내부에 온갖 로직을 구현하게 만듭니다.<br>
저자는 이렇게 이름이 너무 포괄적이라서 목적이 불분명한 클래스를 "**목적 불명 객체**"라고 부릅니다.<br>
목적 불명 객체는 규모가 커지기 쉽습니다.

관심사 분리를 쉽게 하려면, 비즈니스 목적에 따라 이름을 붙여 보면 됩니다.

## 2. 이름 설계하기

프로그래밍에서 이름은 가독성을 높이는 역할만 하는 게 아닙니다.<br>
관심사 분리를 생각하고, 비즈니스 목적에 맞게 "이름을 붙이는 것"은 결합이 느슨하고 응집도가 높은 구조를 만드는 데 중요한 역할을 합니다.

### 2.1 최대한 구체적이고, 의미 범이가 좁고, 특화된 이름 선택하기

목적 중심 이름 설계에서 가장 중요한 포인트 입니다.

특정한 목적을 달성하는 데 특화된 의미 범위가 좁은 이름을 클래스에 붙입니다.<br>
비즈니스 목적에 특화하면 다음과 같은 효과가 생깁니다.

- 이름과 관계없는 로직을 배제하기 쉬워짐
- 클래스가 작아짐
- 관계된 클래스 개수가 적으므로, 결합도가 낮아짐
- 관계된 클래스 개수가 적으므로, 사양 변경 시 생각해야 하는 영향 범위가 좁음
- 목적에 특화된 이름을 갖고 있으므로, 어떤 부분을 변경해야 할 때 쉽게 찾을 수 있음
- 개발 생산성이 향상됨

### 2.2 존재가 아니라 목적을 기반으로 하는 이름 생각하기

예를 들어 "사람"과 "사용자"처럼 단순하게 인물이 존재하기 때문에 붙인 이름은 "존재 기반 이름"이라고 할 수 있습니다.<br>
단순하게 존재를 나타내는 이름은 의미가 여러 곳에서 사용되기 쉬우며, 목적이 불분명해지기 쉽습니다.<br>
결국 로직 레벨에서 혼란을 줍니다.

따라서 구체적인 목적을 알 수 있게, 목적을 기반으로 이름을 짓는 것이 좋습니다.<br>
다음은 존재 기반 이름과 목적 기반 이름의 예시입니다.

| 존재 기반 이름 | 목적 기반 이름                       |
|----------|--------------------------------|
| 주소       | 발송지, 배송지, 업무지                  |
| 금액       | 청구 금액, 소비세액, 연체 보증료, 캠페인 할인 금액 |
| 사용자      | 계정, 개인 프로필, 직무                 |
| 사용자 이름   | 계정 이름, 닉네임(별칭), 본명, 법인명        |
| 상품       | 재고 상품, 예약 상품, 주문 상품, 발송 상품     |

### 2.3 어떤 관심사(비즈니스 목적)가 있는지 분석하기

비즈니스 목적에 특화된 이름을 만들려면, 어떤 비즈니스를 하는지 모두 파악해야 합니다.<br>
이를 위해서는 소프트웨어가 추구하는 목적과 내용을 분석해야 합니다.

등장 인물과 관련 내용을 나열해 보고, 관계를 정리하고 분석해 보세요.<br>
팀이 모두 모여서 화이트보드나 종이에 그려가며 진행하면 좋습니다.<br>
포스트잇을 사용해 관련된 것끼리 묶어 보면 생각이 정리될 것입니다. (DDD"도메인 주도 설계" 느낌)

### 2.4 소리 내어 이야기해 보기

이름도 매우 중요하지만, 어떤 목적을 달성하고 싶은지, 어떤 형태로 사용하고 싶은지,<br>
서로 어떤 관련이 있는지 등 배경과 의도도 함께 정리하고, 이를 팀과 소통해서 일치시키는 것이 중요합니다.

목적과 의도를 다르게 인식하면, 이름이 제대로 된 방향성을 갖지 못할 수도 있습니다.<br>
이를 해결하기 위해 소리내어 팀원과 이야기해보는 것이 중요합니다.

비즈니스 측면을 잘 이해하고 있는 사람과 이야기하는 것도 좋습니다.<br>
목적과 의도를 잘못 인식하고 있는 부분이 있으면 곧바로 피드백을 받을 수 있습니다.<br>
그리고 이야기를 통해서 좀 더 정확하고 구체적인 비즈니스 목적, 목적에 맞는 이름들을 이끌어 낼 수 있을 것입니다.

`고무 오리 디버깅: 프로그래밍에서 어떤 문제가 발생했을 때, 문제를 누군가에게 설명하다 보면 스스로 원인을 깨닫고 해결할 수 있다는 방법입니다.`

소리 내어 말하는 행위 자체가 일종의 분석 행위가 되는 것입니다.

이처럼 이야기하면서 분석하는 활동을 <<도메인 주도 설계>>라는 책에서는 **유비쿼터스 언어**라고 설명합니다.<br>
유비쿼터스 언어란 팀 전체에서 의도를 공유하기 위한 언어입니다.

### 2.5 이용 약관 읽어보기

이용 약관에는 서비스와 관련된 규칙이 굉장히 엄격한 표현으로 작성되어 있습니다.<br>
그래서 이를 활용하면 비즈니스와 관련된 이름을 알 수 있습니다.

다음음 플리마켓 서비스의 이용 약관 일부 예시 입니다.

```text
"구매자"가 구매를 완료한 시점에 "매매 계약"이 체결된 것으로 한다.
매매 계약이 체결되면, "판매자"는 당사에 "서비스 사용료"를 지불해야 한다.
서비스 사용료는 매매 계약이 체결된 시점의 상품 "판매 가격"에 "판매 수수료율"을 곱한 금액이다.
```

비즈니스 규칙과 클래스를 일치하게 만들면, 정확하고 빠르게 변경할 수 있습니다.

### 2.6 다른 이름으로 대체할 수 없는지 검토하기

이름을 정했어도 이름의 의미 범위가 생각보다 넓을 수 있고, 여러 의미가 내포된 이름일 수 있습니다.<br>
그러니 일단 다른 이름으로 바꿔 보고, 의미를 더 좁게 만들 수는 없는지, 이상한 점은 없는지 검토하는 것이 좋습니다.

참고로 다른 이름을 생각할 때는 사전에서 유의어를 확인해 보는 것도 도움이 됩니다.

### 2.7 결합이 느슨하고 응집도가 높은 구조인지 검토하기

목적에 특화된 이름을 선택하면, 목적 이외의 로직을 배제하기 쉬워집니다. 즉, 응집도가 높아집니다.<br>
목적 이외의 로직이 섞인다면, 이름을 잘못 붙인 것은 아닌지 검토해 보세요.

다른 클래스 몇 개와 관련되어 있는지 개수를 확인해 보세요.<br>
여러 개와 관련되어 있다면, 좋지 않은 징조입니다. 강한 결합 상태일 수 있습니다.<br>
의미가 더 좁은 특화된 이름을 찾아보세요.<br>
여러 의미를 갖고 있다면 분해하세요.<br>
관련된 클래스의 개수가 적으면 적을수록 영향 범위가 줄어듭니다.

## 3. 이름 설계 시 주의 사항

### 3.1 이름에 관심 갖기

목적 중심 이름 설계는 "이름에 주의를 기울이고, 이름과 로직을 대응시킨다"라는 접근 방법을 전제로 합니다.<br>
**팀 개발에서는 이름이 중요합니다. 이름과 로직이 대응된다는 전제, 이름이 프로그램 구조를 크게 좌우한다는 사실**을 팀원들과 이야기해야 합니다.

### 3.2 사양 변경 시 "의미 범위 변경" 경계하기

사양 변경에 의해, 개발 맥락에서는 말이 의미하는 바가 점점 변화하는 경우가 있습니다.<br>
따라서 이름 설계는 중간중간 다시 검토해 봐야 합니다.

여러 의미가 섞이면, 이름이 의미하는 바를 다시 검토해 봐야 합니다.<br>
그리고 이름을 변경하거나, 클래스를 나누어야 합니다.

### 3.3 대화에는 등장하지만 코드에 등장하지 않는 이름 주의하기

대화에는 등장하지만 코드에 등장하지 않는 이름은 이를 구현한 사람에게 직접 묻지 않으면 존재조차 알 수 없고,<br>
존재를 확인해도 로직을 이해하기 힘듭니다.

"이름 없는 로직"은 소스 코드 이곳저곳에 무분별하게 작성되는 경향이 있습니다.<br>
이름이 없다는 것은 메서드 또는 클래스로 설계되어 있지 않다는 의미입니다.

대화에서 등장하는 이름을 신경 써야 합니다. 그리고 그 이름을 기반으로 메서드와 클래스를 설계해야 합니다.

### 3.4 수식어를 붙여서 구별해야 하는 경우는 클래스로 만들어 보기

의미가 다르거나 조건에 따라 달라지는 대상을 같은 이름(또는 비슷한 이름)으로 표현하면, 차이를 구별하기 어렵습니다.<br>
결국 동료가 수식어를 붙여 설명하는 상황이 계속될 것입니다.

이런 상황을 막으려면 의미 차이를 확실하게 알 수 있는 이름을 붙여야 합니다.<br>
수식어를 붙이면서까지 차이를 나타내고 싶은 대상은 각각 클래스로 설계하는 것이 좋습니다.<br>
의미가 다른 개념들은 서로 다른 클래스로 설계해서 구조화하면, 개념 사이의 관계를 이해하기 쉽습니다.

아래 예시는 문제가 있는 로직인데 이처럼 수식어를 붙여서 차이를 나타낸다면, 각각을 클래스로 설계할 수 없는지 검토해 보기 바랍니다.

- "이 플래그가 true인 User는 문제 있는 회원입니다."
- "이 줄에 있는 price는 새 제품 가격이고, 다음 줄에 있는 price는 중고 제품 가격입니다."
- "Ticket 클래스는 나이가 60세 이상이면 노인 요금이 되고, 추가로 평일일 때는 평일 노인 요금이 됩니다."

## 4. 의미를 알 수 없는 이름

계산 결과를 임시로 저장하기 위한 지역 변수를 tmp로 만드는 경우가 있습니다.<br>
이렇게 만들 경우, 책무를 알 수 없으며 강한 결합 구조가 되기 쉽습니다.<br>
수정할 때마다 코드를 해석해야 하고, 새로 들어온 팀원에게 설명하는 비용도 커집니다.<br>
부주의로 인해 잘못 해석하는 경우가 생길 수도 있고, 결국 버그를 유발할 수밖에 없습니다.<br>
이를 해결하기 위해 스프레드시트로 용어집과 알람표를 만드는 경우도 있는데,<br>
이러한 자료들은 유지 보수가 거의 되지 않고, 자료 유지 보수에 의해 개발 속도도 느려집니다.

### 4.1 기술 중심 명명

기술을 기반으로 이름 짓는 방법을 기술 중심 명명이라고 부릅니다.<br>
예를 들어 MemoryStateManager와 changeIntValue01 같은 게 있습니다.<br>
이렇게 이름을 지으면 이름의 의도를 알기 어렵습니다.

아래의 표는 대표적인 컴퓨터 기술 용어, 프로그래밍 기술 용어의 예입니다.<br>
이는 소프트웨어를 구현하는 방법일 뿐, 비즈니스 목적을 나타내는 이름에는 적합하지 않으므로 주의해야 합니다.

| 종류          | 예                                 |
|-------------|-----------------------------------|
| 컴퓨터 기술 유래   | memory, cache, thread, register 등 |
| 프로그래밍 기술 유래 | function, method, class, module 등 |
| 자료형 이름 유래   | int, str(string), flag(boolean) 등 |

다만 임베디드처럼 하드웨어와 가까운 레이어의 미들웨어에서는 어쩔 수 없이 기술 중심으로 이름을 짓습니다.<br>
이러한 경우에도 최대한 목적와 의도를 전달할 수 있게 이름을 지어야 합니다.

### 4.2 로직 구조를 나타내는 이름

로직 구조를 그대로 드러내는 이름은 메서드 이름만 보고 무엇을 의도하는 지 알기 힘듭니다.<br>
```java
// 게임에서 멤버가 마법을 사용할 수 있는 상태인지 판정하는 로직
// 로직 구조를 그대로 드러내는 메서드 이름
boolean isMemberHpMoreThanZeroAndIsMemberCanActAndIsMemberMpMoreThanMagicCostMp(Member member)

// 의도와 목적을 이해하기 쉽게 붙인 이름
boolean canEnchant(final Member member)
```

### 4.3 놀람 최소화 원칙

놀람 최소화 원칙이란 사용자가 예상하지 못한 놀라움을 최소화하도록 설계해야 한다는 접근 방법입니다.<br>
이를 위해서는 로직과 이름을 잘 대응시켜야 합니다.

처음에는 로직과 의도가 일치하게끔 구현했다고 해도, 사양을 변경하면서 점차 이름과 로직 사이에 괴리가 생실 수 있습니다.<br>
이러면 놀람 최소화 원칙을 위반하게 된 것입니다.<br>
이는 메서드 레벨 뿐만 아니라, 클래스 레벨에서도 발생할 수 있는 문제이므로 주의가 필요합니다.

로직과 이름 사이에 괴리가 있다면 이름을 수정하거나, 메서드와 클래스를 의도에 맞게 따로 만드세요.

## 5. 구조에 악영향을 미치는 이름

### 5.1 데이터 클래스처럼 보이는 이름

~Info와 ~Data 같은 이름의 클래스는 읽는 사람에서 "데이터만 갖는 클래스니까, 로직을 구현하면 안되는 구나"라는 이미지를 심어줄 수 있습니다.<br>
결국 응집도가 낮은 구조가 되기 쉽습니다.

ProductInfo는 Product로 개선하는 것이 좋습니다.<br>
그리고 객체 지향 설계에 따라서 인스턴스 변수와 관련이 깊은 로직들을 Product에 캡슐화해야 합니다.

**DTO(Data Transfer Object)**

예외적으로 데이터 클래스를 사용하는 경우가 있습니다.<br>
변경 책무와 참조 책무를 모듈로 분리하는 명령 쿼리 역할 분리(이하 CQRS)라고 불리는 아키텍처 패턴이 있습니다.<br>
CQRS에서 참조 책무란 데이터베이스에서 값을 추출하는 처리로서, 오직 화면 출력만 하면 됩니다.<br>
이는 DTO라고 해서, 데이터 전송 용도로 사용되는 디자인 패턴입니다.<br>
값 변겨잉 필요 없으므로, 인스턴스 변수는 final로 선언하고 생성자에서는 값만 지정합니다.<br>
참조 용도로만 사용되어야 하므로, 값을 변경하는 용도로 사용하면 안됩니다.<br>
만약 변경 용도로 사용하면 응집도가 낮은 구조가 됩니다.

### 5.2 클래스를 거대하게 만드는 이름

대표적인 이름으로는 Manager가 있습니다.<br>
Manager라는 이름의 클래스는 여러 책무를 떠안기 쉬워 단일 책임 원칙을 위반할 수 있습니다.<br>
결국 갓 클래스가 되는 것입니다.

Manager 이름이 붙은 클래스는 단순하게 "관련이 있으니까 거기에 두었다"라는 이유로<br>
여러 책무를 가진 로직이 모이고, 질서 없는 상태에 빠집니다.

Manager와 마찬가지로 Processor와 Controller 같은 이름도 주의해야 합니다.<br>
이러한 이름은 의미가 넓게 해석되어 클래스를 거대하게 만들 수 있습니다.

책무가 다른 로직은 다른 클래스로 정의하세요.

### 5.3 상황에 따라 의미가 달라질 수 있는 이름

상황(컨텍스트)가 달라지면, 관련된 개념이 서로 반대가 될 수도 있습니다.

예를 들어 Car 클래스에 배송 상황(컨텍스트)와 판매 상황(컨텍스트)가 있다고 치면,<br>
배송 컨텍스트에는 발송지, 배송지, 배송 경로 등이 필요하고,<br>
판매 컨텍스트에는 판매 가격, 판매 옵션 등이 필요합니다.<br>
결국 아래와 같은 클래스가 탄생합니다.

```text
class Car{
    id
    발송지
    배송지
    배송 경로
    판매 가격
    판매 옵션
}
```

이는 Car 클래스가 여러 로직을 갖게 되어 클래스가 거대해지고 개발자가 이해하기 어렵게 됩니다.

컨텍스트가 다르다면, 분리해서 느슨한 결합으로 설계하는 것이 좋습니다.<br>
각 컨텍스트는 서로 다른 패키지로 선언합니다.<br>
그리고 각 패키지에 Car 클래스를 만듭니다.<br>
이어서 각각의 컨텍스트에 등장하는 개념을 클래스로 만들어 Car 클래스와 연결합니다.

어떤 컨텍스트가 둘러싸고 있는지 분석하세요.<br>
그리고 컨텍스트별로 경계를 지어 보세요.<br>
이를 기반으로 각 컨텍스트별로 클래스를 설계하면 됩니다.

### 5.4 일련번호 명명

클래스와 메서드의 이름에 번호를 붙여 만드는 것을 **일련번호 명명**이라고 부릅니다.<br>
일련번호로 이름을 붙이면 이름을 바꾸는 것도 힘듭니다.<br>
여러 클래스와 메서드가 일련번호로 관리되고 있으므로, 일련번호가 아닌 방식으로 이름을 지으면 질서가 무너져 버립니다.<br>
일련번호라는 질서를 유지하기 위해, 기능을 추가할 때 기존의 메서드에 로직을 추가하기 쉽습니다.<br>
따라서 트랜잭션 스크립트 패턴이 되기 쉽습니다.

## 6. 이름을 봤을 때, 위치가 부자연스러운 클래스

### 6.1 "동사+목적어" 형태의 메서드 이름 주의하기

클래스의 메서드들 중에서 관심사가 다른 메서드는 "동사+목적어" 형태가 되는 경향이 있습니다.<br>
클래스를 잘 설계하려는 습관이 들어 있지 않다면, 이러한 경향이 더 짙어집니다.<br>
그리고 메서드 이름과 관련된 규율이 없다면, 책무가 다른 메서드가 계속 추가될 것입니다.<br>
결국 다른 클래스에서도 같은 기능을 가진 메서드가 생성되어 중복 코드가 발생합니다.

### 6.2 가능하면 메서드의 이름은 동사 하나로 구성되게 하기

"동사+목적어" 형태의 메서드<br>
&downarrow;<br>
목적어의 개념을 나타내는 클래스를 따로 만듭니다.<br>
그리고 그 클래스에 "동사 하나" 형태의 메서드를 추가합니다.

이렇게 하면 일급 컬렉션 패턴(컬렉션과 관련된 로직을 캡슐화한 디자인 패턴)을 적용한 클래스가 만들어집니다.

```text
일급 컬렉션 패턴 (7장 참고)
- 컬렉션 자료형의 인스턴스 변수
- 컬렉션 자료형의 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드
```

### 6.3 부적절한 위치에 있는 boolean 메서드

관심사에 주의를 기울이지 않으면, boolean 자료형을 리턴하는 판정 메서드는 관계없는 클래스(해당 책무를 갖지 않는 클래스)에 구현되기 쉽습니다.

boolean 자료형의 메서드를 추가할 때는 "클래스 is 상태" 형태로 읽어 봤을 때 자연스러운 영어 문장이 되는지 확인해 보기 바랍니다.

## 7. 이름 축약

### 7.1 의도를 알 수 없는 축약

의도를 알 수 없게 축약되면 해석하는 시간이 추가적으로 필요합니다.

### 7.2 기본적으로 이름은 축약하지 말기

변수명뿐만 아니라, 메서드 이름, 클래스 이름, 패키지 이름도 축약하지 않고 모두 작성하는 것이 좋습니다.<br>
가독성이 높아지면, 동료는 물론이고 미래의 자신에게도 도움이 됩니다.

일반적으로도 축약한 이름이 통용된다면 축약해도 괜찮다고 생각합니다.<br>
예를 들어서 SNS, VIP 등은 관습적으로 축약한 형태로 사용하므로, 의미를 전달하는 데 아무 문제 없습니다.

### 7.3 이름을 축약할 수 있는 경우

저자는 최대한 축약하지 않고, 의도를 명확하게 전달하는 것이 중요하다고 생각합니다.<br>
이름을 축약할 때는 의미가 사라지지 않는지, 추가적인 다른 문제가 발생하지는 않는지 등을 꼭 확인해 보세요.<br>
예를 들어 카운터 변수 i와 j처럼 범위가 작고, 의미가 헷갈릴 여지가 적다면 이름을 축약해도 괜찮습니다.<br>

명명 방법을 팀이나 회사 차원에서 결정해 두는 것도 좋습니다.
