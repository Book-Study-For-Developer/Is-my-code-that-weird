# 5장 응집도: 흩어져 있는 것들

**응집도**란 '모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지 나타내는 지표'입니다.<br>
모듈은 클래스, 패키지, 레이어 등을 모두 포함할 수 있는 용어입니다.

응집도가 높은 구조는 변경하기 쉬우며, 바람직한 구조입니다. <br>
반대로 응집도가 낮은 구조는 변경 시 문제가 발생하기 쉽습니다.


## 1. static 메서드 오용
다음은 데이터는 MoneyData에 있고, 데이터를 조작하는 로직은 OrderManager에 있어서 응집도가 낮은 구조의 예시입니다.
```java
// moneyData1의 값과 moneyData2의 값을 합치는 코드
moneyData1.amount = OrderManager.add(moneyData1.amoumt, moneyData2.amount);
```
(물론 moneyData1.amount에 값을 재할당하는 문제도 있습니다.)

### 1.1 static 메서드는 인스턴스 변수를 사용할 수 없음
어떤 메서드를 static 메서드로 만든 시점에 이미 데이터와 데이터를 조작하는 로직 사이에 괴리가 발생합니다.<br>
클래스가 스스로 보호할 수 있게, 데이터와 로직을 모아 응집도가 높은 구조로 설계하는 것이 객체 지향 설계의 기본입니다.

### 1.2 인스턴스 변수를 사용하는 구조로 변경하기
응집도를 높이기 위해서는 '인스턴스 변수'와 '인스턴스 변수를 사용하는 로직'을 같은 클래스에 만들어야 합니다.

### 1.3 인스턴스 메서드인 척하는 static 메서드 주의하기
static 키워드가 붙어 있지 않을 뿐, static 메서드와 같은 문제를 갖고 있는 인스턴스 메서드로 자주 볼 수 있습니다.
```java
class PaymentManager {
    private int discountRate; // 할인율
    
    // 생략
    int add(int moneyAmount1, int moneyAmount2) {
        return moneyAmount1 + moneyAmount2;
    }
}
```
위의 코드는 인스턴스 변수 discountRate를 전혀 사용하지 않습니다.<br>
이처럼 인스턴스 메서드인 척하는 static 메서드도 응집도를 낮춥니다.

`메서드 앞에 static 키워드를 추가했을 때 오류가 발생하지 않는다면 인스턴스 메서드인 척하는 static 메서드 입니다.`

### 1.4 왜 static 메서드를 사용할까?
static 메서드를 사용하는 이유는 객체 지향 언어를 사용할 때, C 언어 같은 절차 지향 언어의 접근 방법을 사용하려 하기 때문입니다. <br>
절차 지향 언어에서는 데이터와 로직이 따로 존재하도록 설계합니다.

### 1.5 어떠한 상황에서 static 메서드를 사용해야 좋을까?
응집도의 영향을 받지 않는 경우 static 메서드를 사용해도 괜찮습니다.<br>
예를 들어, 로그 출력 전용 메서드, 포맷 변환 전용 메서드 등이 있습니다.<br>
또한, 팩토리 메서드도 static 메서드로 설계하는 것이 좋습니다.
```java
// 팩토리 메서드 예시
class GiftPoint {
    private static final int MIN_POINT = 0;
    private static final int STANDARD_MEMBERSHIP_POINT = 3000;
    private static final int PREMIUM_MEMBERSHIP_POINT = 10000;
    final int value;

    private GiftPoint(final int point) {
        if (point < MIN_POINT) {
            throw new IllegalArgumentException("포인트는 0 이상이어야 합니다.");
        }
        value = point;
    }
    
    // 팩토리 메서드 1
    static GiftPoint forStandardMembership() {
        return new GiftPoint(STANDARD_MEMBERSHIP_POINT);
    }
    
    // 팩토리 메서드 2
    static GiftPoint forPremiumMembership() {
        return new GiftPoint(PREMIUM_MEMBERSHIP_POINT);
    }
}
```

## 2. 초기화 로직 분산
클래스를 잘 설계해도, 초기화 로직이 분산되어 응집도가 낮은 구조가 되어버리는 경우가 있습니다.

### 2.1 private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화하기
위의 1.5의 예시 코드처럼 private 생성자 + 팩토리 메서드로 객제를 생성하면 초기화 로직의 분산을 막을 수 있습니다.

### 2.2 생성 로직이 너무 많아지면 팩토리 클래스를 고려해 보자
상황에 따라 생성 로직이 너무 많아지면 해당 클래스가 무엇을 하는 클래스인지 알기 어렵습니다.<br>
생성 로직이 너무 많아지는 것 같다면, 생성 전용 팩토리 클래스를 분리하는 방법을 고려하는 것이 좋습니다.

## 3. 범용 처리 클래스 (Common / Util)
static 메서드를 빈번하게 볼 수 있는 클래스로, 범용 처리를 위한 클래스가 있습니다.<br>
일반적으로 Common, Util이라는 이름이 붙습니다.<br>
문제는 static 메서드와 마찬가지로 응집도가 낮은 구조가 만들어질 수 있다는 것입니다.

참고로 static 메서드는 응집도를 낮추는 문제만 가져오는 게 아니라, <br>
전역 변수가 나타나게 되는 등 여러가지 악영향을 미칩니다.

### 3.1 너무 많은 로직이 한 클래스에 모이는 문제
Common, Util이라는 이름 자체가 '범용'이라는 뜻이기 때문에, <br>
읽는 사람에게 '범용적으로 사용하고 싶은 로직은 Common 클래스에 모아 두면 되겠구나'라고 생각하게 만듭니다.

근복적인 원인은 범용의 의미와 재사용성을 잘못 이해하고 있기 때문입니다.<br>
재사용성은 설계의 응집도를 높이면, 저절로 높아집니다.

### 3.2 객체 지향 설계의 기본으로 돌아가기
꼭 필요한 경우가 아니라면 범용 처리 클래스를 만들지 않는 것이 좋습니다.

### 3.3 횡단 관심사
다양한 상황에서 넓게 사용되는 기능을 **횡단 관심사**라고 부릅니다.
- 로그 출력
- 오류 확인
- 디버깅
- 예외 처리
- 캐시
- 동기화
- 분산 처리

횡단 관심사에 해당하는 기능이라면 범용 코드로 만들어도(static 메서드로 만들어도) 괜찮습니다.

## 4. 결과를 리턴하는 데 매개변수 사용하지 않기
```java
class ActorManager {
    // 게임 캐릭터 위치를 이동
    void shift(Location location, int shiftX, int shiftY) {
        location.x += shiftx;
        location.y += shiftY;
    }
}
```
위와 같이 입력으로 들어온 매개변수의 값을 변경하는 것을 출력 매개변수라고 부릅니다.<br>
이는 데이터는 Location, 데이터를 조작하는 로직은 ActorManager에 있는 응집도가 낮은 구조 입니다.<br>
'데이터'와 '데이터를 조작하는 로직'을 같은 클래스에 배치하도록 합니다.

## 5. 매개변수가 너무 많은 경우
너무 많은 매개변수를 받는 메서드는 실수로 잘못된 값을 대입할 가능성이 높습니다.<br>
또한, 중복 코드가 발생할 가능성이 높아집니다.

이러한 문제는 왜 생기는 것일까요?<br>
매개변수가 많다는 것은 많은 기능을 처리하고 싶다는 의미입니다.<br>
하지만 처리할 게 많아지면 로직이 복잡해지거나, 중복 코드가 생길 가능성이 높아집니다.

### 5.1 기본 자료형에 대한 집착
기본 자료형을 남용하는 현상을 **기본 자료형 집착**이라고 합니다.<br>
프로그래밍 초보자, 혹은 경력이 많더라도 줄곧 기본 자료형만을 써 온 개발자가 기본 자료형 집착에 빠지기 쉽습니다.<br>
'아니, 이 정도를 집착이라고 할 수 있나? 일반적인 구현 스타일인 것 같은데?', '클래스를 많이 만드는 것이 오히려 이상해 보이는데?'라고 생각할 수 있습니다.<br>
하지만 기본 자료형으로만 구현하면, 중복 코드가 많이 발생하고, 계산 로직이 이곳저곳 분산되기 쉽습니다.<br>
기본 자료형만으로도 '동작하는 코드'를 작성할 수 있습니다.<br>
하지만 그럴 경우, `관련 있는 데이터와 로직을 집약하기 힘듭니다(응집도가 낮은 구조). 따라서 버그가 생기기 쉽고, 가독성이 떨어집니다.`

### 5.2 의미 있는 단위는 모두 클래스로 만들기
매개변수가 많으면 데이터 하나하나를 매개변수로 다루지 말고, 그 데이터들을 인스턴스 변수로 갖는 클래스를 만들고 활용하는 설계로 변경하는 방법이 있습니다.

## 6. 메서드 체인
```java
/**
 * 갑옷 입기
 * @param memberId 장비를 변경하고 싶은 멤버의 ID
 * @param newArmor 입을 갑옷
 */
void equipArmor(int memberId, Armor newArmor) {
    if (party.members[memberId].equipments.canChange) {
        party.members[memberId].equipments.armor = newArmor;
    }
}
```
이처럼 .(점)으로 여러 메서드를 연결해서 리턴 값의 요소에 차례차례 접근하는 방법을 **메서드 체인**이라고 부릅니다.<br>
이 방법도 응집도를 낮출 수 있어 좋지 않은 작성 방법입니다.

예를 들어서 members, equipments, canChange, armor에 접근하는 코드가 여러곳에 중복되어 구현되어 있다고 합시다.<br>
이러한 요소의 사양이 조금이라도 변경되면, 해당 요소에 접근하고 있던 모든 코드를 확인하고 수정해야 할 것입니다.<br>
또한 버그가 발생했다면, 어디에서 발생한 것인지 모든 코드를 확인해야 할 것입니다.

이처럼 영향이 미치는 범위가 커질 수 있는 구조이므로, 전역 변수와 같은 성질을 갖습니다.<br>
어디서든 아무 요소에나 접근할 수 있는 구조이므로, 사실 하나의 전역 변수보다 훨씬 악질적입니다.

**데메테르의 법칙** : 사용하는 객체 내부를 알아서는 안된다는 법칙 (단순하게 '모르는 사람에게 말 걸지 않기'라고 설명하기도 합니다.)

메서드 체인으로 내부 구조를 돌아다닐 수 있는 설계는 데메테르의 법칙을 위반한다고 할 수 있습니다.

### 6.1 묻지 말고 명령하기
소프트웨어 설계에는 '**묻지 말고, 명령하기**(Tell, Don's Ask)'라는 유명한 격언이 있습니다.<br>
다른 객체의 내부 상태(변수)를 기반으로 판단하거나 제어하려고 하지 말고, 메서드로 명령해서 객체가 알아서 판단하고 제어하도록 설계하라는 의미입니다.

인스턴스 변수를 private으로 변경해서, 외부에서 접근할 수 없게 합니다.<br>
그리고 인스턴스 변수에 대한 제어는 외부에서 메서드로 명령하는 형태로 만듭니다.<br>
상세한 판단과 제어는 명령을 받는 쪽에서 담당하게 합니다.
