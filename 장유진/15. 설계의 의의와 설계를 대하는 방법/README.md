# 15장 설계의 의의와 설계를 대하는 방법

## 1. 이 책은 어떤 설계를 주제로 집필한 것인가?

이 책에서 다뤄 왔던 것은 유지 보수성과 관련된 설계입니다.

유지 보수성은 '시스템이 정상 운용되도록 유지 보수하기가 얼마나 쉬운가를 나타내는 정도'라고 했습니다.<br>
유지 보수성의 부가적인 특성을 보면, 수정성이라는 것이 있습니다.<br>
수정성은 변경 용이성이라고도 부르며, (버그를 발생시키지 않고도) 얼마나 쉽고 정확하게 코드를 변경할 수 있는지 나타내는 지표입니다.<br>
유지 보수성 중에서도 특히 변경 용이성을 목적으로 하는 설계 방법을 다루어 온 것입니다.

## 2. 설계하지 않으면 개발 생산성이 저하된다

변경하기 어렵고 버그가 생기기 쉬운 코드를 **레거시 코드**라고 합니다.<br>
그리고 레거시 코드가 축적되어 있는 상태를 **기술 부채**라고 합니다.<br>
변경 용이성 설계를 하지 않으면, 개발 생산성이 저하됩니다.

### 2.1 요인 1: 버그가 발생하기 쉬운 구조

- 응집도가 낮은 구조로 인해 사양 변경 시 수정 누락이 발생
- 코드를 이해하기 어려우므로 구현할 때 실수를 저지르기 쉬워짐
- 잘못된 값이 들어오기 쉬워짐

### 2.2 요인 2: 가독성이 낮은 구조

- 읽고 이해하는 데 시간이 오래 걸림
- 관련된 로직이 이곳저곳에 흩어져 있어, 사양을 변경할 때 관련된 로직을 찾아서 돌아다니는 데 시간이 오래 걸림
- 잘못된 값이 들어와서 버그가 발생했을 때, 잘못된 값의 출처를 추적하기 어려워짐

### 2.3 나무꾼의 딜레마

'날이 무딘 도끼라서 나무가 잘 베이지 않지만, 날을 갈 시간이 없는 상태'를 의미합니다.

제대로 설계하지 않으면, 로직 변경과 디버그에 많은 시간을 소비하게 됩니다.<br>
결국 설계할 시간 여유조차 없어지는 딜레마에 빠지게 됩니다.

### 2.4 열심히 일했지만 생산성이 나쁨

개발 생산성이 나쁘면 새로운 기능을 릴리스하는 데 굉장히 오래 걸립니다.<br>
당연하지만 수익을 내기 힘듭니다.<br>
고질적으로 성과를 낼 수 없게 되어 버리는 것입니다.

### 2.5 국가 규모의 경제 손실

복잡하고 이해하기 힘든 로직이 있으면, 이로 인해 더 복잡하고 이해하기 힘든 로직이 만들어지기 때문입니다.

## 3. 소프트웨어와 엔지니어의 성장 가능성

코드의 변경 용이성이 높을수록, 소프트웨어의 가치를 빠르게 높일 수 있습니다.<br>
소프트웨어가 빠르게 성장하는 것입니다.

소프트웨어의 성장 가능성을 높이는 것이 바로 이 책의 핵심 주제이자 의의입니다.

### 3.1 엔지니어에게 자산이란 무엇인가?

엔지니어에게 자산은 기술력입니다.<br>
엔지니어가 기술력이 있다면, 모아 놓은 돈이 없어도 어디서든 돈을 벌 수 있습니다.<br>
레거시 코드는 이러한 자산의 축적, 즉 기술력의 성장을 방해하는 무서운 존재입니다.

### 3.2 레거시 코드는 발전을 막음

레거시 코드는 다음 사람으로 하여금 레거시 코드를 작성하게 합니다.<br>
즉, 낮은 수준의 기술만 사용하게 만듭니다.

### 3.3 레거시 코드는 고품질 설계 경험을 막음

레거시 코드는 이미 균형이 깨져 있어서, 설계를 개선하기가 매우 힘듭니다.<br>
결국에는 고품질 설계 구현 경험을 쌓을 수 없으므로, 설계 능력이 향상되지 않습니다.

### 3.4 레거시 코드는 시간을 낭비하게 만듦

레거시 코드는 이해하는 데 시간이 오래 걸립니다.<br>
설계 능력뿐만 아니라 그 밖의 다양한 기술 향상도 이룰 수 없게 되어 버립니다.<br>
레거시 코드는 기술 향상을 막고, 엔지니어에게 정말 중요한 자산이라 할 수 있는 기술력의 축적을 막습니다.

## 4. 문제 해결하기

### 4.1 문제를 인식하지 못하면 설계에 대한 생각 자체가 떠오르지 않음

### 4.2 인지하기 쉬운 문제와 인지하기 어려운 문제가 있음

보임 + 플러스 가치 : 신기능<br>
보임 + 마이너스 가치 : 버그<br>
안보임 + 플러스 가치 : 아키텍처<br>
안보임 + 마이너스 가치 : 기술 부채

소스 코드를 독해하는 싈과 기술 부채를 인식하는 스킬은 전혀 다릅니다.

### 4.3 이상적인 형태를 알아야 문제를 인식할 수 있음

이상적인 형태가 어떤 것인지 스스로 자세하게 정의할 수 있어야 혼자서 연습할 수 있습니다.<br>
이상이 무엇인지 알고 있다면, 현실과 비교하며 차근차근 문제를 해결할 수 있습니다.<br>
이상적인 설계와 현재 설계를 비교하면, 기술 부채를 인식할 수 있습니다.

### 4.4 변경 용이성을 비교할 수 없는 딜레마

'변경 용이성 설계 팀'과 '설계하지 않은 팀'이라는 두 개의 개발 리소스를 준비해야 합니다.<br>
매일매일 바쁘게 돌아가고, 리소스가 부족한 개발 현장에서 변경 용이성을 검증하기 위해서 예산과 인원을 투자하기는 솔직히 어려운 일입니다.

## 5. 코드의 좋고 나쁨을 판단하는 지표

코드 복잡성과 가독성 등의 품질 지표를 **코드 메트릭** 또는 **소프트웨어 메트릭**이라고 부릅니다.

### 5.1 실행되는 코드의 줄 수

줄 수가 많으면 많을수록, 너무 많은 일을 하고 있을 가능성이 높습니다.<br>
저자는 메서드=10줄 이내, 클래스=100줄 이내를 제안합니다.

클래스를 작게 분할하는 것에 거부감을 느끼는 사람들도 꽤 많습니다.<br>
표준 라이브러를 생각해 봅시다.<br>
표준 라이브러리 클래스는 사용 방법과 사양이 명확하고, 신뢰성이 높으므로 내부 구조를 따로 신경 쓰지 않아도 됩니다.<br>
이러한 관점에서 생각해보면, 분할된 로직이 신경 쓰이는 이유는 '분할된 클래스의 동작이 불안하기 때문'이라고 할 수 있습니다.<br>
즉 신뢰성이 낮을수록, 내부 로직이 신경 쓰이는 것입니다.<br>
'클래스 하나하나가 정상적으로 동작하도록 설계하는 것이 중요'하고 신경쓰지 않아도 되는 구조로 만들어야 합니다.

### 5.2 순환 복잡도

순환 복잡도는 코드의 구조적인 복잡함을 나타내는 지표입니다.<br>
조건 분기, 반복 처리, 중첩이 많아지면 복잡도가 커집니다.<br>
이 책에서 다룬 조기 리턴, 전략 패턴, 일급 컬렉션 등의 테크닉을 활용하면 복잡도를 줄일 수 있습니다.

### 5.3 응집도

응집도는 모듈 내부에서 데이터와 로직이 관련되어 있는 정도를 나타내는 지표입니다.<br>
응집도가 높을수록 변경 용이성이 높고 좋은 구조입니다.

### 5.4 결합도

결합도는 모듈 간의 의존도를 나타내는 지표입니다.<br>
결합돡 높을수록 더 넓은 범위를 고려해야 하므로, 유지 보수와 사양 변경이 어렵습니다.<br>
결합도가 너무 높으면, 클래스가 너무 많은 일을 하고 있을 수 있습니다.<br>
즉, 단일 책임 원칙을 위배하고 있을 수 있습니다.

### 5.5 청크

최근 인지 심리학 연구 결과에 따르면, 인간의 단기 기억은 한 번에 4+-1개의 개념 정도만 파악할 수 있다고 합니다.<br>
그래서 이 숫자를 **매지컬 넘버 4**라고 부릅니다.<br>
또한 기억할 수 있는 정보 덩어리의 단위를 **청크**라고 부릅니다.

클래스를 설계할 때도 매지컬 넘버 4를 염두에 두고, 클래스에서 다루는 개념이 4+-1개 정도가 되도록 설계하고,<br>
이보다 큰 클래스는 작은 클래스로 분할하는 것이 좋습니다.

## 6. 코드 분석을 지원하는 다양한 도구

- Code Climate Quality
- Understand
- Visual Studio

## 7. 설계 대상과 비용 대비 효과

### 7.1 파레토의 법칙(80:20의 법칙)

전체 결과의 80%가 전체 원인의 20%에서 일어난다는 법칙입니다.<br>
중요하고 사양 변경이 빈번한 곳의 설계를 개선하면, 비용 대비 효과가 높을 것입니다.

### 7.2 코어 도메인: 서비스의 중심 영역

서비스에서 중심이 되는 비즈니스 영역을 '도메인 주도 설계'에서는 **코어 도메인**이라고 합니다.

- 시스템에서 가장 큰 가치를 창출하는 곳
- 가치 있고 중요하고 비용 대비 효과가 가장 큰 곳
- 경쟁 우위에 있고, 차별점을 만들며, 비즈니스 우위를 만들 수 있는 곳

### 7.3 중점 설계 대상 선정에는 비즈니스 지식이 필요함

대상을 잘 선정하려면, 서비스가 해결하고 싶은 고객 과제가 무엇인지, 서비스의 본질이 무엇인지 볼 수 있는 능력이 필요합니다.<br>
즉, 서비스와 관련된 비즈니스 지식이 필요합니다.

## 8. 시간을 다스리는 능력자 되기

변경 용이성 설계는 개발 생산성을 향상시킵니다.<br>
특히 미래의 시간을 다룰 수 있습니다.<br>
레거시 코드를 안고 계속해서 기술 부채를 쌓아갈지, 소프트웨어를 빠르게 성장시킬지는 모두 설계자의 능력에 달려 있습니다.<br>
어려운 능력이지만, 누구나 훈련하면 습득할 수 있습니다.<br>
머릿속에 그리는 능력과 설계 능력을 활용하면 미래의 시간을 조종할 수 있습니다.
