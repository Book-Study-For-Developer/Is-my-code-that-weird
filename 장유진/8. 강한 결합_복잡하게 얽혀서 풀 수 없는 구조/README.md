# 8장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조

**결합도**란 모듈 사이의 의존도를 나타내는 지표입니다.

어떤 클래스가 다른 클래스에 많이 의존하고 있는 구조를 **강한 결합**이라고 부릅니다.<br>
강한 결합 코드는 이해하기도 힘들고, 변경하기도 굉장히 힘듭니다.

결합도가 낮은 구조를 **느슨한 결합**이라고 부릅니다.<br>
느슨한 결합 구조로 개선하면 코드 변경이 쉬워집니다.

책무를 제대로 생각하지 않으면 결합도가 높아지기 쉽습니다.

소프트웨어 설계에서 책무란 '어떤 관심사를 정상적으로 작동하게 제어해야 하는 책임'입니다.

## 1. 결합도와 책무

책무를 생각하지 않으면 어떤 문제가 발생할 지 온라인 쇼핑몰을 예시로 살펴봅시다.

어떤 온라인 쇼핑물에 '일반 할인'이라는 할인 서비스가 추가되었습니다.<br>
일반 할인의 사양은 다음과 같습니다.
- 상품 하나당 3,000원 할인
- 최대 200,000원까지 상품 추가 가능

담당자는 다음과 같이 코드를 구현했습니다.<br>
코드는 편의상 한글로 작성합니다.

```text
class 할인 관리자 {
  멤버 변수 : List<상품>, 총 금액
  멤버 함수 : 상품 추가, 할인된 가격 계산
  
  상품 추가(상품, 상품 할인 정보) :
    1. 올바른 상품인지 확인
      1-1. 상품 id가 정상적인지 확인
      1-2. 상품 이름이 정상적인지 확인
      1-3. 상품 가격이 정상적인지 확인
      1-4. '상품'의 상품 id랑 '상품 할인 정보'의 상품 id가 동일한지 확인
    2. '할인된 가격 계산'함수를 호출해서 가격 계산
    3. '상품 할인 정보'에서 canDiscount 확인
      3-1. 할인 가능한 경우, '총 금액'에 할인된 가격 더하기
      3-2. 할인 불가능한 경우, '총 금액'에 원래 가격 더하기
    4. '총 금액'이 200,000원이 안 넘을 경우 'List<상품>'에 상품 추가 및 '총 금액'에 해당 금액 반영

  할인된 가격 계산(정가) :
    1. 정가에서 3000원 할인
    2. 할인가가 0 이하면 0으로 변환 후 할인가 리턴
}

class 상품 {
  멤버 변수 : 상품 id, 상품명, 가격 
}

class 상품 할인 정보 {
  멤버 변수 : 상품 id, canDiscount
}
```

그런데 이후, 일반 할인 이외에 여름 할인 사양이 추가되었습니다.

- 상품 하나당 3,000원 할인
- 최대 300,000원까지 상품 추가 가능

할인 관리자 클래스를 구현한 담당자가 아닌 다른 담당자가 다음과 같이 구현했습니다.<br>
비슷한 코드가 많아서 '할인 관리자' 클래스를 사용하기로 했습니다.

```text
class 여름 할인 관리자 {
  멤버 변수 : 할인 관리자
  멤버 함수 : 상품 추가
  
  상품 추가(상품) :
    1. 올바른 상품인지 확인
      1-1. 상품 id가 정상적인지 확인
      1-2. 상품 이름이 정상적인지 확인
    2. '상품'에서 canDiscount 확인
      2-1. 할인 가능한 경우, '할인 관리자'의 '할인된 가격 계산' 함수를 호출하여 할인가 계산 후 '할인 관리자'.'총금액'에 더하기
      2-2. 할인 불가능한 경우, '할인 관리자'.'총금액'에 정가 더하기
    3. '총 금액'이 300,000원이 안 넘을 경우 '할인 관리자'.'총금액'에 가격 반영 및 '할인 관리자'.'List<상품>'에 상품 추가
}

class 상품 {
  멤버 변수 : 상품 id, 상품명, 가격, canDiscount // 여기서 canDiscount는 여름 할인 가능한지 여부
}
```

### 1.1 다양한 버그
위와 같이 코드를 구현할 경우 다양한 버그가 발생할 수 있습니다.

어느 날 일반 할인 가격을 3,000원에서 4,000원으로 변경했습니다.<br>
'할인 관리자' 구현 담당자는 '할인된 가격 계산' 함수 로직에서 할인가를 4,000원으로 변경했습니다.<br>
이렇게 하면 여름 할인의 할인 가격도 4,000원으로 변경되어 버립니다.

이 외에도 다음과 같은 버그가 발생합니다.

- 여름 할인에 가격 확인 로직이 없음 -> 여름 할인에 정가가 음수인 상품을 추가할 수 있음
- 상품의 canDiscount와 상품 할인 정보의 canDiscount를 혼돈 -> 할인 대상 상품이 할인이 되지 않음

### 1.2 로직의 위치에 일관성이 없음

- '할인 관리자'와 '여름 할인 관리자'가 상품 정보 확인 외에 너무 많은 일을 하고 있습니다.
- '상품'이 직접 해야하는 유효성 검사 로직이 '할인 관리자'와 '여름 할인 관리자'에 구현되어 있습니다.
- canDiscount의 이름이 유사해서 구분하기 힘듭니다.
- 여름 할인 가격 계산을 위해 '여름 할인 관리자'가 '할인 관리자'의 할인 로직을 사용하고 있습니다.

이런 클래스 설계는 **책무를 고려하지 않은 설계**입니다.

### 1.3 단일 책임 원칙
소프트웨어의 책임이란 '자신의 관심사와 관련해서, 정상적으로 동작하도록 제어하는 것'이라고 할 수 있습니다.

단일 책임 원칙은 '클래스가 담당하는 책임은 하나로 제한해야 한다'는 설계 원칙입니다.

### 1.4 단일 책임 원칙 위반으로 발생하는 악마
다음과 같은 사항이 단일 책임 원칙을 위반했다고 할 수 있습니다.

- '할인 관리자'의 할인 로직은 여름 할인을 위한 것이 아닙니다.
- 상품명과 가격이 타당한지 확인은 '상품' 클래스가 가지고 있어야 합니다.

### 1.5 책임히 하나가 되게 클래스 설계하기

```text
class 정가 {
  static 멤버 변수 : 최소 금액 0원
  멤버 변수 : 가격
  
  생성자(입력 가격) : 입력 가격이 최소 금액 0원보다 큰지 확인 후 객체 생성
}

class 일반 할인 {
  static 멤버 변수 : 최소 금액 0원, 할인 금액 4,000원
  멤버 변수 : 가격
  
  생성자(입력 가격) : 입력 가격 - 할인 금액(4,000원)이 최소 금액 이상인지 확인 후 객체 생성
}

class 여름 할인 {
  static 멤버 변수 : 최소 금액 0원, 할인 금액 3,000원
  멤버 변수 : 가격
  
  생성자(입력 가격) : 입력 가격 - 할인 금액(3,000원)이 최소 금액 이상인지 확인 후 객체 생성
}
```
이렇게 설계할 경우 일반 할인과 여름 할인이 분리되어 있어서 서로 영향을 주지 않습니다.

이와 같이 관심사에 따라 분리해서 독립되어 있는 구조를 **느슨한 결합**이라고 합니다.

### 1.6 DRY(Don't Repeat Yourself) 원칙의 잘못된 적용
위의 코드에서 할인 금액이 다른 것만 제외하면 모든 코드가 동일합니다.<br>
이를 보고 '중복 코드가 작성된 것은 아닐까?'라고 생각할 수 있습니다.<br>
하지만 여름 할인이 3,000원이 아니라 5%로 변경되면 로직이 아예 달라집니다.

이처럼 책무를 생각하지 않고 로직의 중복을 제거하면 안됩니다.<br>
그렇게 되면 하나로 모인 로직이 여러 책무를 담당해야 합니다.

DRY 원칙은 직역하면 '반복을 피해라'라는 의미입니다.<br>
일부 사람은 이를 '코드 중복을 절대 허용하지 말라'로 받아들입니다.<br>
하지만 이 원칙을 소개한 책을 보면 다음과 같이 설명합니다.

`모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.`

여기서 '지식'이란 소프트웨어가 대상으로 하는 비즈니스 지식입니다.<br>
비즈니스 지식이란 소프트웨어에서 다루는 비즈니스 개념으로 예를 들어 '할인', '상품', '이벤트' 등 입니다.

DRY는 각각의 개념 단위 내에서 반복을 하지말라는 의미입니다.<br>
**같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 합니다.**<br>
개념적으로 다른 것까지도 무리하게 중복을 제거하려 하면, 강한 결합 상태가 됩니다.<br>
단일 책임 원칙이 깨지는 것입니다.

### 1 챕터 마무리

저자가 만든 영상 중 '일반화의 덫'의 내용을 소개합니다.

1. 여러 클래스에 비슷한 작업을 처리하는 코드가 있어 이를 범용 처리 모듈로 만들었습니다.
2. 범용 처리 모듈이 꽤 괜찮아서, 다른 클래스도 이 모듈에 의존하기 시작합니다.
3. 그런데 사양 변경이 이루어져, 범용 처리 모듈 내 의존 클래스마다 작업을 전담하는 로직이 별개로 구현됩니다.
4. 각 클래스의 로직을 변경하고 싶어도 이미 너무 많은 것을 범용 처리 모듈에 의존하고 있어 분해도 못하고, 이러지도 저러지도 못하는 상황이 됩니다.

중복 코드를 제거하려면, 일반화를 사용하면 됩니다.<br>
하지만 일반화하면 안되는 코드가 있습니다.<br>
DRY 원칙 정의에서도 언급했던 것처럼 개념이 다른 코드는 일반화하면 안됩니다.<br>
처리를 일반화해도 되는지는 이 장에서 살펴보았던 할인 예처럼, 같은 비즈니스 개념인지 확인하면 알 수 있습니다.

그런데 비즈니스에 대한 이해가 높아지면서, 같은 비스니스 개념이라고 생각했던 것들이 사실 서로 다른 개념이었음을 뒤늦게 인지하게 될 수도 있습니다.<br>
서로 다른 개념임을 알게 되었다면, 곧바로 일반화했던 것을 다시 나누는 등 구조 변경을 검토하도록 합시다.


## 2. 다양한 강한 결합 사례와 대처 방법





