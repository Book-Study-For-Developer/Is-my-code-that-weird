# 8장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조

**결합도**란 모듈 사이의 의존도를 나타내는 지표입니다.

어떤 클래스가 다른 클래스에 많이 의존하고 있는 구조를 **강한 결합**이라고 부릅니다.<br>
강한 결합 코드는 이해하기도 힘들고, 변경하기도 굉장히 힘듭니다.

결합도가 낮은 구조를 **느슨한 결합**이라고 부릅니다.<br>
느슨한 결합 구조로 개선하면 코드 변경이 쉬워집니다.

책무를 제대로 생각하지 않으면 결합도가 높아지기 쉽습니다.

소프트웨어 설계에서 책무란 '어떤 관심사를 정상적으로 작동하게 제어해야 하는 책임'입니다.

## 1. 결합도와 책무

책무를 생각하지 않으면 어떤 문제가 발생할 지 온라인 쇼핑몰을 예시로 살펴봅시다.

어떤 온라인 쇼핑물에 '일반 할인'이라는 할인 서비스가 추가되었습니다.<br>
일반 할인의 사양은 다음과 같습니다.
- 상품 하나당 3,000원 할인
- 최대 200,000원까지 상품 추가 가능

담당자는 다음과 같이 코드를 구현했습니다.<br>
코드는 편의상 한글로 작성합니다.

```text
class 할인 관리자 {
  멤버 변수 : List<상품>, 총 금액
  멤버 함수 : 상품 추가, 할인된 가격 계산
  
  상품 추가(상품, 상품 할인 정보) :
    1. 올바른 상품인지 확인
      1-1. 상품 id가 정상적인지 확인
      1-2. 상품 이름이 정상적인지 확인
      1-3. 상품 가격이 정상적인지 확인
      1-4. '상품'의 상품 id랑 '상품 할인 정보'의 상품 id가 동일한지 확인
    2. '할인된 가격 계산'함수를 호출해서 가격 계산
    3. '상품 할인 정보'에서 canDiscount 확인
      3-1. 할인 가능한 경우, '총 금액'에 할인된 가격 더하기
      3-2. 할인 불가능한 경우, '총 금액'에 원래 가격 더하기
    4. '총 금액'이 200,000원이 안 넘을 경우 'List<상품>'에 상품 추가 및 '총 금액'에 해당 금액 반영

  할인된 가격 계산(정가) :
    1. 정가에서 3000원 할인
    2. 할인가가 0 이하면 0으로 변환 후 할인가 리턴
}

class 상품 {
  멤버 변수 : 상품 id, 상품명, 가격 
}

class 상품 할인 정보 {
  멤버 변수 : 상품 id, canDiscount
}
```

그런데 이후, 일반 할인 이외에 여름 할인 사양이 추가되었습니다.

- 상품 하나당 3,000원 할인
- 최대 300,000원까지 상품 추가 가능

할인 관리자 클래스를 구현한 담당자가 아닌 다른 담당자가 다음과 같이 구현했습니다.<br>
비슷한 코드가 많아서 '할인 관리자' 클래스를 사용하기로 했습니다.

```text
class 여름 할인 관리자 {
  멤버 변수 : 할인 관리자
  멤버 함수 : 상품 추가
  
  상품 추가(상품) :
    1. 올바른 상품인지 확인
      1-1. 상품 id가 정상적인지 확인
      1-2. 상품 이름이 정상적인지 확인
    2. '상품'에서 canDiscount 확인
      2-1. 할인 가능한 경우, '할인 관리자'의 '할인된 가격 계산' 함수를 호출하여 할인가 계산 후 '할인 관리자'.'총금액'에 더하기
      2-2. 할인 불가능한 경우, '할인 관리자'.'총금액'에 정가 더하기
    3. '총 금액'이 300,000원이 안 넘을 경우 '할인 관리자'.'총금액'에 가격 반영 및 '할인 관리자'.'List<상품>'에 상품 추가
}

class 상품 {
  멤버 변수 : 상품 id, 상품명, 가격, canDiscount // 여기서 canDiscount는 여름 할인 가능한지 여부
}
```

### 1.1 다양한 버그
위와 같이 코드를 구현할 경우 다양한 버그가 발생할 수 있습니다.

어느 날 일반 할인 가격을 3,000원에서 4,000원으로 변경했습니다.<br>
'할인 관리자' 구현 담당자는 '할인된 가격 계산' 함수 로직에서 할인가를 4,000원으로 변경했습니다.<br>
이렇게 하면 여름 할인의 할인 가격도 4,000원으로 변경되어 버립니다.

이 외에도 다음과 같은 버그가 발생합니다.

- 여름 할인에 가격 확인 로직이 없음 -> 여름 할인에 정가가 음수인 상품을 추가할 수 있음
- 상품의 canDiscount와 상품 할인 정보의 canDiscount를 혼돈 -> 할인 대상 상품이 할인이 되지 않음

### 1.2 로직의 위치에 일관성이 없음

- '할인 관리자'와 '여름 할인 관리자'가 상품 정보 확인 외에 너무 많은 일을 하고 있습니다.
- '상품'이 직접 해야하는 유효성 검사 로직이 '할인 관리자'와 '여름 할인 관리자'에 구현되어 있습니다.
- canDiscount의 이름이 유사해서 구분하기 힘듭니다.
- 여름 할인 가격 계산을 위해 '여름 할인 관리자'가 '할인 관리자'의 할인 로직을 사용하고 있습니다.

이런 클래스 설계는 **책무를 고려하지 않은 설계**입니다.

### 1.3 단일 책임 원칙
소프트웨어의 책임이란 '자신의 관심사와 관련해서, 정상적으로 동작하도록 제어하는 것'이라고 할 수 있습니다.

단일 책임 원칙은 '클래스가 담당하는 책임은 하나로 제한해야 한다'는 설계 원칙입니다.

### 1.4 단일 책임 원칙 위반으로 발생하는 악마
다음과 같은 사항이 단일 책임 원칙을 위반했다고 할 수 있습니다.

- '할인 관리자'의 할인 로직은 여름 할인을 위한 것이 아닙니다.
- 상품명과 가격이 타당한지 확인은 '상품' 클래스가 가지고 있어야 합니다.

### 1.5 책임히 하나가 되게 클래스 설계하기

```text
class 정가 {
  static 멤버 변수 : 최소 금액 0원
  멤버 변수 : 가격
  
  생성자(입력 가격) : 입력 가격이 최소 금액 0원보다 큰지 확인 후 객체 생성
}

class 일반 할인 {
  static 멤버 변수 : 최소 금액 0원, 할인 금액 4,000원
  멤버 변수 : 가격
  
  생성자(입력 가격) : 입력 가격 - 할인 금액(4,000원)이 최소 금액 이상인지 확인 후 객체 생성
}

class 여름 할인 {
  static 멤버 변수 : 최소 금액 0원, 할인 금액 3,000원
  멤버 변수 : 가격
  
  생성자(입력 가격) : 입력 가격 - 할인 금액(3,000원)이 최소 금액 이상인지 확인 후 객체 생성
}
```
이렇게 설계할 경우 일반 할인과 여름 할인이 분리되어 있어서 서로 영향을 주지 않습니다.

이와 같이 관심사에 따라 분리해서 독립되어 있는 구조를 **느슨한 결합**이라고 합니다.

### 1.6 DRY(Don't Repeat Yourself) 원칙의 잘못된 적용
위의 코드에서 할인 금액이 다른 것만 제외하면 모든 코드가 동일합니다.<br>
이를 보고 '중복 코드가 작성된 것은 아닐까?'라고 생각할 수 있습니다.<br>
하지만 여름 할인이 3,000원이 아니라 5%로 변경되면 로직이 아예 달라집니다.

이처럼 책무를 생각하지 않고 로직의 중복을 제거하면 안됩니다.<br>
그렇게 되면 하나로 모인 로직이 여러 책무를 담당해야 합니다.

DRY 원칙은 직역하면 '반복을 피해라'라는 의미입니다.<br>
일부 사람은 이를 '코드 중복을 절대 허용하지 말라'로 받아들입니다.<br>
하지만 이 원칙을 소개한 책을 보면 다음과 같이 설명합니다.

`모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.`

여기서 '지식'이란 소프트웨어가 대상으로 하는 비즈니스 지식입니다.<br>
비즈니스 지식이란 소프트웨어에서 다루는 비즈니스 개념으로 예를 들어 '할인', '상품', '이벤트' 등 입니다.

DRY는 각각의 개념 단위 내에서 반복을 하지말라는 의미입니다.<br>
**같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 합니다.**<br>
개념적으로 다른 것까지도 무리하게 중복을 제거하려 하면, 강한 결합 상태가 됩니다.<br>
단일 책임 원칙이 깨지는 것입니다.

### 1 챕터 마무리

저자가 만든 영상 중 '일반화의 덫'의 내용을 소개합니다.

1. 여러 클래스에 비슷한 작업을 처리하는 코드가 있어 이를 범용 처리 모듈로 만들었습니다.
2. 범용 처리 모듈이 꽤 괜찮아서, 다른 클래스도 이 모듈에 의존하기 시작합니다.
3. 그런데 사양 변경이 이루어져, 범용 처리 모듈 내 의존 클래스마다 작업을 전담하는 로직이 별개로 구현됩니다.
4. 각 클래스의 로직을 변경하고 싶어도 이미 너무 많은 것을 범용 처리 모듈에 의존하고 있어 분해도 못하고, 이러지도 저러지도 못하는 상황이 됩니다.

중복 코드를 제거하려면, 일반화를 사용하면 됩니다.<br>
하지만 일반화하면 안되는 코드가 있습니다.<br>
DRY 원칙 정의에서도 언급했던 것처럼 개념이 다른 코드는 일반화하면 안됩니다.<br>
처리를 일반화해도 되는지는 이 장에서 살펴보았던 할인 예처럼, 같은 비즈니스 개념인지 확인하면 알 수 있습니다.

그런데 비즈니스에 대한 이해가 높아지면서, 같은 비스니스 개념이라고 생각했던 것들이 사실 서로 다른 개념이었음을 뒤늦게 인지하게 될 수도 있습니다.<br>
서로 다른 개념임을 알게 되었다면, 곧바로 일반화했던 것을 다시 나누는 등 구조 변경을 검토하도록 합시다.


## 2. 다양한 강한 결합 사례와 대처 방법

### 2.1 상속과 관련된 강한 결합

상속은 주의해서 다루지 않으면, 곧바로 강한 결합 구조를 유발하는 위험한 문법입니다.

이 책에서는 상속 자체를 권장하지 않습니다.<br>
상속은 여러 객체 지향 프로그래밍 입문서에서 소개하는 개념입니다.<br>
하지만 숙련된 엔지니어 커뮤니티에서는 상속과 관련해 의문을 많이 제기하고, 상속을 위험하게 여기는 경향이 있습니다.

**슈퍼 클래스 의존**

상속 관계에서 서브 클래스는 슈퍼 클래스에 굉장히 크게 의존합니다.<br>
따라서 서브 클래스는 슈퍼 클래스의 구조를 하나하나 신경 써야 합니다.<br>
슈퍼 클래스의 변화를 놓치는 순간, 버그가 만들어질 수 있습니다.<br>
일반적으로 슈퍼 클래스는 서브 클래스를 딱히 신경 쓰지 않고 변경합니다.<br>
그래서 서브 클래스에 문제가 발생하기 쉽습니다.

**상속보다 컴포지션**

슈퍼클래스 의존으로 인한 강한 결합을 피하려면, 상속보다 컴포지션을 사용하는 것이 좋습니다.<br>
컴퓨지션이란 사용하고 싶은 클래스를 private 인스턴스 변수로 갖고 사용하는 것을 의미합니다.<br>
컴퓨지션 구조를 사용하면 인스턴스 변수 클래스의 로직을 변경해도 영향을 적게 받습니다.

**상속을 사용하는 나쁜 일반화**

상속을 사용하면 서브 클래스가 슈퍼 클래스의 로직을 그대로 사용하게 되므로, 슈퍼 클래스가 공통 로직을 두는 장소로 사용됩니다.<br>
상속으로 무리하게 일반화하려고 하면 강한 결합이 발생하기 쉽습니다.<br>
다음과 같은 것들이 문제가 될 수 있습니다.

- 오버라이드 시 메서드 사양 변경
- 공통된 부분을 슈퍼 클래스에서 일반화
- 차이가 있는 부분만 서브 클래스에서 오버라이드
- 슈퍼 클래스의 메서드를 완전히 새로 오버라이드
- 슈퍼 클래스에 상속받는 측(서브 클래스)의 로직을 구현

상속은 다른 동작을 구현하기 위해 사용하는 것입니다.<br>
상속은 **전략 패턴 등으로 조건 분기를 줄일 때** 활용할 수 있습니다.

상속받는 쪽에서 차이가 있는 로직만 구현하는 템플릿 메서드라는 디자인 패턴도 있습니다.<br>
즉, 잘만 설계하면 상속도 아무 문제 없습니다.<br>
하지만 **상속은 강한 결합과 로직 분산 등 여러 문제를 불러들입니다.** 따라서 신중하게 사용해야 합니다.

상속은 반드시 **단일 책임 원칙**을 염두에 두고 구현하도록 합시다.<br>
그리고 **값 객체**와 **컴포지션** 등 다른 설계를 사용할 수는 없는지 반드시 검토해 보기 바랍니다.

### 2.2 인스턴스 변수별로 클래스 분할이 가능한 로직

책임이 다른 메서드가 한 클래스 안에 정의되어 있으면, 여러 문제가 발생할 수 있습니다.<br>
실제 제품 코드에서는 클래스 간 의존 관계가 매우 복잡합니다.<br>
관계를 파악할 때는 **영향 스케치**라는 의존 관계 그림을 그려서 해결할 수 있습니다.
영향 스케치는 직접 그려도 되고, 소스 코드를 자동으로 분석해서 그려주는 여러 도구(ex: Jig)를 활용해도 좋습니다.

### 2.3 특별한 이유 없이 public 사용하지 않기

특별한 이유 없이 public을 붙이면, 강한 결합 구조를 유발할 수 있습니다.<br>
관계를 맺지 않았으면 하는 클래스끼리도 결합되어, 영향 범위가 확대됩니다.<br>
결과적으로 유지보수가 어려운 강한 결합 구조가 되어버립니다.

강한 결합을 피하려면, **접근 제어자**(public, protected, private, 없음)로 가시성을 적절하게 제어해야 합니다.<br>

접근 제어자 '없음'은 보통 package private 입니다.<br>
이는 패키지들의 불필요한 의존 관계를 피할 때 package private이 적잘하기 때문입니다.<br>
패키지는 밀접한 클래스끼리 응집하게 설계합니다. 반면 패키지 바깥의 클래스와는 느슨하게 결합하도록 설계합니다.

클래스는 기본적으로 package private으로 만듭니다.<br>
패키지 외부에 공개할 필요가 있는 클래스에 한해서만 public으로 선언합시다.

### 2.4 private 메서드가 너무 많다는 것은 책임이 너무 많다는 것

소프트웨어의 기능이 많아질수록 클래스는 점점 커집니다. 규모가 커진 클래스에는 여러 개의 메서드가 정의됩니다.

private 메서드(public 메서드도 포함)가 너무 많이 쓰인 클래스는 하나가 아닌 너무 많은 책임을 갖고 있을 가능성이 높습니다.<br>
여러 책임 로직이 private 메서드로 구현되어 있는 것입니다.

책임이 다른 메서드는 각각의 다른 클래스로 분리하는 것이 좋습니다.

### 2.5 높은 응집도를 오해해서 생기는 강한 결합

**응집도가 높다는 개념을 염두에 두고, 관련이 깊다고 생각되는 로직을 한곳에 모으려고 했지만, 결과적으로 강한 결합 구조를 만드는 상황은 매우 자주 일어납니다.**<br>
그렇기 때문에 '**결합이 느슨하고 응집도가 높은 설계**'라고 한 덩어리로 묶어 이야기하는 경우가 많습니다.

### 2.6 스마트 UI

`스마트 UI : 화면 표시를 담당하는 클래스 중에서 화면 표시와 직접적인 관련이 없는 책무가 구현되어 있는 클래스`

스마트 UI는 화면 표시에 관한 책무와 그렇지 않은 책무가 강하게 결합되어 있기 때문에, 변경하기 아주 힘듭니다.<br>
이들은 서로 다른 클래스로 분할하는 것이 좋습니다.

### 2.7 거대 데이터 클래스

설계를 고려하지 않고 구현하다 보면, 수많은 데이터가 모일 수 있습니다.<br>
또한, 데이터가 많아지다 보면 클래스를 '데이터를 편리하게 운반하는 역할'로 인식하고 데이터를 계속 추가하기 쉽습니다.

이렇게 사용할 경우, 특정 유스케이스와 관련없는 데이터에 접근하고 그 데이터를 사용하게 되면,<br>
부주의한 변경으로 인해서 버그가 발생할 가능성이 높아집니다.<br>
거대 데이터 클래스는 다양한 데이터를 가지므로, 수많은 유스케이스에서 사용됩니다.<br>
결국 전역 변수와 같은 성질을 띄게 됩니다.<br>
동기화하느라 성능이 저하되는 등 전역 변수와 동일한 유형의 다양한 폐해가 발생합니다.

### 2.8 트랜잭션 스크립트 패턴

`트랜잭션 스크립트 패턴 : 메서드 내부에 일련의 처리가 하나하나 길게 작성되어 있는 구조`

'데이터를 보유하고 있는 클래스(데이터 클래스)'와 '데이터를 처리하는 클래스'를 나누어 구현할 때 자주 발생하는 형태입니다.<br>
이를 남용하면 수백 줄의 거대한 로직을 갖게 되어, 응집도는 낮아지고 결합은 강해지므로 변경하기 매우 어려워집니다.

### 2.9 갓(God) 클래스

`갓 클래스 : 하나의 클래스 내부에 수천에서 수만 줄의 로직을 담고 있으며, 수많은 책임을 담당하는 로직이 난잡하게 섞여있는 클래스`

트랜잭션 스크립트 패턴에서 한 단계 더 나아가면, 갓 클래스가 됩니다.<br>
'신'이라는 이름이 붙었지만 굉장히 악마같은 클래스 입니다.

일단 어떤 로직과 관련 있는지, 책무를 파악하기가 굉장히 힘듭니다.<br>
또한 기능을 수정하려면, 영향 범위를 파악하기 위해 수천 수만 줄의 로직을 읽어야 합니다.<br>
영향 범위 확인 시 놓치는 부분이 생기기 쉬우므로, 버그가 스며들기도 쉽습니다.<br>
일반적으로 잘못된 값을 검출하는 로직조차 난잡하게 작성되어 있는 경우가 많으며,<br>
최악의 상황에는 아예 작성되어 있지 않은 경우도 있습니다.

### 2.10 강한 결합 클래스 대처 방법

거대 데이터 클래스, 트랜잭션 스크립트 패턴, 갓 클래스처럼 강한 결합 클래스에 대처하는 방법은 모두 같습니다.<br>
지금까지 설명했던 **객체 지향 설계와 단일 책임 원칙에 따라 제대로 설계하는 것**입니다.

거대한 강한 결합 클래스는 책임별로 클래스를 분할해야 합니다.<br>
단일 책임 원칙에 따라 설계된 클래스는 아무리 많아도 200줄 정도, 일반적으로 100줄 정도입니다.

조기 리턴, 전략 패턴, 일급 컬렉션 등 이 책에서 소개하는 다양한 방법을 활용해 볼 수 있으며, 목적 중심 이름 설계 방법도 큰 도움이 됩니다.
