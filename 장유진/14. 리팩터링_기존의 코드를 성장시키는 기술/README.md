# 14장 리팩터링: 기존의 코드를 성장시키는 기술

## 1. 리팩터링의 흐름

**리팩터링**이란 실질적인 동작은 유지하면서, 구조만 정리하는 작업입니다.

### 1.1 중첩을 제거하여 보기 좋게 만들기

조건 판정을 위해 if 조건문을 여러 번 중첩하고 있으면 가독성이 매우 좋지 않습니다.<br>
조기 리턴을 활용하여 조건을 반전해서 if 조건문의 중첩을 제거해 봅시다.

### 1.2 의미 단위로 로직 정리하기

조건 확인과 값 대입 로직을 각각 분리해서 정리합니다.

### 1.3 조건을 읽기 쉽게 하기

유효하지 않은 구매자 계정을 `if (!customer.isEnabled())`로 판정하고 있다고 칩시다.<br>
논리 부정 연산자 '!'를 사용하고 있으므로, 코드를 읽을 때 한 번 더 생각해서 '유효하지 않다'라고 바꿔 읽어야 하므로 가독성이 떨어집니다.<br>
이런 경우 클래스에 유효하지 않은 계정인지 여부를 리턴하는 isDisabled 메서드를 추가해 봅시다.

### 1.4 무턱대로 작성한 로직을 목적을 나타내는 메서드로 바꾸기

## 2. 단위 테스트로 리팩터링 중 실수 방지하기

실제 프로덕션 코드는 훨씬 복잡하므로, 리팩터링 난이도가 굉장히 높습니다.<br>
아무리 주의를 기울이더라도, 인간의 주의력에는 한계가 있습니다.<br>
실수로 인해 동작에 변화가 생기면, 버그가 발생할 수 있습니다.

가장 확실하게 실수를 줄일 수 있는 방법으로는 단위 테스트가 있습니다.<br>
단위 테스트는 작은 기능 단위로 동작을 검증하는 테스트를 의미합니다.<br>
일반적으로는 '테스트 프레임워크와 테스트 코드를 활용해서 메서드 단위로 동작을 검증하는 방법'이라고 생각해도 괜찮습ㄴ디ㅏ.

리팩터링을 할 때 단위 테스트는 필수입니다.<br>
일반적으로 악마를 불러들이는 나쁜 코드에는 테스트 코드가 작성되어 있지 않은 경우가 많습니다.<br>
그럼 테스트가 없는 프로덕션 코드가 있다고 가정하고, 테스트 코드를 작성하고 리팩터링하는 과정에 대해서 설명하겠습니다.

다음은 리팩터링 대상 코드입니다.
```java
/**
 * 배송 관리 클래스
 */
public class DeliveryManager {
    /**
     * 배송비를 리턴함.
     * @param products 배송 대상 상품 리스트
     * @return 배송비
     */
    public static int deliveryChange(List<Product> products) {
        int charge = 0;
        int totalPrice = 0;
        for (Product each : products) {
            totalPrice += each.price;
        }
        if (totalPrice < 20000) {
            charge = 5000;
        } 
        else {
            charge = 0;
        }
        return charge;
    }
}
```

### 2.1 코드 과제 정리하기

일단 이 '과제'와 '이상적인 구조'에 대해서 생각해 본 다음 리팩터링하겠습니다.

static 메서드는 데이터와 데이터를 조작하는 로직을 분리해서 정의할 수 있는 구조이므로, 응집도가 낮아지기 쉽습니다.<br>
'배송비'는 금액을 나타내는 개념이므로, 값 객체를 만들면 좋을 것 같습니다.<br>
합계 금액은 장바구니를 확인할 때, 실제로 주문할 때 등 다양한 유스케이스에 사용됩니다.<br>
따라서 각각의 메서드에서 따로 계산하면, 로직이 중복될 가능성이 높습니다.

### 2.2 테스트 코드를 사용한 리팩터리 흐름

1. 이상적인 구조의 클래스 기본 형태를 어느 정도 잡습니다.
2. 이 기본 형태를 기반으로 테스트 코드를 작성합니다.
3. 테스트를 실패시킵니다.
4. 테스트를 성공시키기 위한 최소한의 코드를 작성합니다.
5. 기본 형태의 클래스 내부에서 리팩터링 대상 코드를 호출합니다.
6. 테스트가 성공할 수 있도록, 조금씩 로직을 이상적인 구조로 리팩터링 합니다.

#### 이상적인 구조의 클래스 기본 형태를 어느 정도 잡기

현재 예에서는 구매할 상품 목록, 즉 장바구니를 나타내는 클래스의 기본적인 형태를 만들면 됩니다.<br>
ShoppingCart라는 클래스를 만들었다고 칩시다.<br>
합계 금액 계산은 ShoppingCart 클래스에서 할 것입니다.<br>
그리고 배송비를 나타내는 DeliveryCharge 클래스를 만듭니다.<br>
DeliveryCharge 생성자의 매개변수로 ShoppingCart 인스턴스를 전달하게 합니다.

현재 단계에서는 ShoppingCart와 DeliveryCharge가 기본적인 사양을 만족하지 못합니다.<br>
이제 이러한 미완성된 클래스를 대상으로 하는 테스트를 작성하고, DeliveryManager의 로직을 차근차근 옮겨서 완성된 클래스로 만들면 됩니다.

#### 테스트 코드 작성하기

앞선 리팩터링 대상 코드를 기준으로 테스트 코드를 작성합니다.

#### 테스트 실패시키기

기대한 대로 실패 혹은 성공하지 않는다면 테스트 코드나 프로덕션 코드 중 어딘가에 오류가 있다는 것이므로 주의합니다.

#### 테스트 성공시키기

성공시킨다고 처음부터 본격적으로 구현하는 것은 아닙니다.<br>
테스트를 성공시키기 위한 최소한의 코드만 구현합니다.

#### 리팩터링하기

리팩토링을 진행하면서 중간에 실수로 로직을 잘못 작성하면, 테스트가 실패하므로 곧바로 알아차릴 수 있을 것입니다.<br>
따라서 안전하게 로직을 변경할 수 있습니다.

## 3. 불확실한 사양을 이해하기 위한 분석 방법

사양을 제대로 모른다면, 리팩터링을 위한 테스트 코드를 작성할 수 없습니다. 이럴 때는 어떻게 해야 할까요?<br>
<레거시 코드 활용 전략>은 '테스트가 없는 코드에 테스트를 추가해서 안전하게 리팩터링할 수 있는 여러 가지 테크닉'을 소개합니다.

### 3.1 사양 분석 방법 1: 문서화 테스트

문서화 테스트는 메서드의 사양을 분석하는 방법입니다.<br>
다음은 문서화 테스트 예시입니다.

| 매개변수 v | 매개변수 flag | 리턴 값 |
|--------|-----------|------|
| 1000   | false     | 1000 |
| 2000   | false     | 2000 |
| 3000   | false     | 3000 |
| 1000   | true      | 1100 |
| 2000   | true      | 2200 |
| 3000   | true      | 3300 |

문서화 테스트는 분석하고 싶은 메서드의 테스트를 작성해서, 해당 메서드가 어떤 동작을 하는지 확인하는 방법입니다.<br>
물론 실제로 문서화 테스트만으로 사양을 완벽하게 밝히기는 굉장히 어렵습니다.<br>
그래도 메서드 내부의 로직, 어떠한 유스케이스에서 호출되는지 등 복합적으로 분석하면서 사양을 조금이라도 명확하게 만들 수 있습니다.<br>
사양의 단서를 찾는 방법 중 하나라고 생각하세요.

### 3.2 사양 분석 방법 2: 스크래치 리팩터링

실제 프로덕션 코드는 굉장히 복잡하고 기괴해서, 이상적인 구조 자체를 유추하기 어려운 경우도 많습니다.<br>
이러한 상황에서 유용하게 쓸 수 있는 분석 방법이 바로 **스크래치 리팩터링**입니다.<br>
이는 정식 리팩터링이 아니라, 로직의 의미와 구조를 분석하기 위해 시험 삼아 리팩터링하는 것입니다.

일단 대상 코드를 레포지터리에서 체크아웃 합니다.<br>
이어서 테스트 코드를 따로 작성하지 않고, 코드를 리팩터링합니다.<br>
코드가 정리되어 가독성이 좋아지면, 다음과 같은 장점이 생깁니다.

- 코드의 가독성이 좋아져 로직의 사양을 이해할 수 있게 됩니다.
- 이상적인 구조가 보입니다. 어느 범위를 메서드 또는 클래스로 끊어야 좋을 지 보입니다. 즉, 리팩터링의 목표가 조금씩 보일 것입니다.
- 쓸데없는 코드(데드 코드)가 보입니다.
- 테스트 코드를 어떻게 작성해야 할지 보입니다.

스크래치 리팩터링으로 분석한 결과를 기반으로, 이상적인 구조를 떠올릴 수 있습니다.<br>
이상적인 구조를 떠올렸다면, 테스트 코드를 작성하면서 정식으로 리팩터링하면 됩니다.<br>
추가로, 스크래치 리팩터링은 어디까지나 분석용이므로, 레포지터리에 병합해서는 안 됩니다.<br>
역할을 마쳤다면 그냥 파기해야 합니다.

## 4. IDE의 리팩터링 기능

IntelliJ IDEA의 편리한 리팩토링 기능 두 가지를 소개합니다.

### 4.1 리네임(이름 변경)

한 번에 클래스, 메서드, 변수의 이름을 전부 변경하는 리팩터링 기능입니다.

### 4.2 메서드 추출

이 기능은 거대한 로직 내부에서 의미 있는 로직 덩어리를 따로 꺼내고 싶을 때 유용합니다.<br>
'테스트 코드를 작성하고 싶은 부분적인 로직이 있는데, 거대한 로직에 묻혀 있어서 테스트할 수 없는' 상황에 활용할 수 있습니다.

## 5. 리팩터링 시 주의 사항

### 5.1 기능 추가와 리팩터링 동시에 하지 않기

<리팩터링 2판>을 보면, 이러한 전환을 '두 개의 모자'라고 표현합니다.<br>
작업을 할 때는 '기능 추가 모자'와 '리팩터링 모자' 중에서 하나만 쓰고 있어야 한다는 표현이 나옵니다.

### 5.2 작은 단계로 실시하기

예를 들어 리팩터링으로 메서드 이름 변경과 로직 이동을 했다면, 커밋을 따로따로 구분하는 것이 좋습니다.<br>
여러 번 커밋했다면, 풀 리퀘스트를 작성하는 것이 좋습니다.<br>
변경이 많으면 다른 사람이 변경한 코드와 충돌할 수 있습니다.<br>
또한 리팩터링한 코드가 불완전할 때, 롤백하기도 어렵습니다.

### 5.3 불필요한 사양은 제거 고려하기

리팩터링 전에 불필요한 사양이 있는지, 사양을 다시 확인하는 것도 좋습니다.<br>
불필요한 사양과 코드를 미리 제거할 수 있다면, 더 쾌적하게 리팩터링할 수 있습니다.
